// DBDeployer - The MySQL Sandbox
// Copyright Â© 2006-2018 Giuseppe Maxia
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package common

import (
	"fmt"
	"slices"
	"testing"

	"github.com/datacharmer/dbdeployer/compare"
	"github.com/datacharmer/dbdeployer/globals"
)

func TestSafeTemplateFill(t *testing.T) {
	var template = `[{{.AppVersion}}] {{.Article}} {{.Adjective}} {{.Noun}} {{.Verb}} {{.Object}}`
	var tests = []struct {
		data     StringMap
		expected string
	}{
		{
			StringMap{
				"Article":   "The",
				"Adjective": "nice",
				"Noun":      "squirrel",
				"Verb":      "eats",
				"Object":    "nuts"},
			// The AppVersion field is generated by SafeTemplateFill
			fmt.Sprintf("[%s] The nice squirrel eats nuts", VersionDef),
		},
		{
			StringMap{
				"Article":   "An",
				"Adjective": "ugly and huge",
				"Noun":      "*orc*",
				"Verb":      "follows",
				"Object":    "the hobbits"},
			fmt.Sprintf("[%s] An ugly and huge *orc* follows the hobbits", VersionDef),
		},
	}
	for _, test := range tests {
		result, err := SafeTemplateFill("tmpl1", template, test.data)
		if err == nil && result == test.expected {
			t.Logf("ok - string formatted as expected: '%s'\n", result)
		} else {
			t.Logf("not ok - SafeTemplatedFill(?,%q,%+v) failed. Got: %s, Expected: %s\n", template, test.data, result, test.expected)
			t.Fail()
		}
	}
	template = `{{.DateTime}}`
	// The DateTime field is auto generated
	data := StringMap{}
	result, err := SafeTemplateFill("tmpl2", template, data)
	compare.OkIsNil("filling template 2", err, t)
	//             Sun Oct    7  07: 42: 24 CEST 2018
	reExpected := `\w+ \w+\s+\d+ \d+:\d+:\d+ \w+ \d+`
	compare.OkMatchesString("Timestamp", result, reExpected, t)

	// Checks that a missing variables raises an error
	template = `{{.NoSuchVar}} {{.SuchVarExists}}`
	data = StringMap{"SuchVarExists": "something"}
	result, err = SafeTemplateFill("tmpl3", template, data)
	compare.OkEqualString("empty result", result, globals.EmptyString, t)
	compare.OkIsNotNil("filling template 3", err, t)
	compare.OkMatchesString("filling template string", err.Error(), `NoSuchVar`, t)
}

func TestStringMapAdd(t *testing.T) {
	type StringMapTest = struct {
		orig     StringMap
		add      StringMap
		expected StringMap
	}
	tests := []StringMapTest{
		{StringMap{}, StringMap{}, StringMap{}},
		{StringMap{"a": "a1"}, StringMap{}, StringMap{"a": "a1"}},
		{StringMap{"a": "a1"}, StringMap{"a": "a1"}, StringMap{"a": "a1"}},
		{StringMap{"a": "a1"}, StringMap{"b": "b1"}, StringMap{"a": "a1", "b": "b1"}},
		{StringMap{"b": "b1"}, StringMap{"a": "a1"}, StringMap{"a": "a1", "b": "b1"}},
	}

	for _, test := range tests {
		orig := test.orig
		got := orig.Add(test.add)
		// test got values are in expected
		for k, v := range got {
			_, ok := test.expected[k]
			if !ok {
				t.Errorf("%v.Add(%+v) failed. Value in got not found in expected. key: %v, value: %+v", got, test.add, k, v)
			}
		}
		// test expected values are in got
		for k, v := range test.expected {
			_, ok := got[k]
			if !ok {
				t.Errorf("%v.Add(%+v) failed. Value in expected not found in got. key: %v, value: %+v", test.expected, test.add, k, v)
			}
		}
	}
}

func TestGetVarsFromTemplate(t *testing.T) {
	tests := []struct {
		content  string
		expected []string
	}{
		{"", []string{}},
		{"{{.Var1}}", []string{"Var1"}},
		{"{{.Var1}},{{.Var2}}", []string{"Var1", "Var2"}},
		{"{{.Var1}},{{.Var2}},{{.Var3}}", []string{"Var1", "Var2", "Var3"}},
		{"{{.Var1}},{{.Var2}},{{.Var3}},{{.Var1}}", []string{"Var1", "Var2", "Var3"}},
		{"{{.Var3}},{{.Var1}},{{.Var2}},{{.Var2}}", []string{"Var1", "Var2", "Var3"}},
		{"{{.Var3}} {{.Var1}} {{.Var2}} {{.Var2}}", []string{"Var1", "Var2", "Var3"}},
		{"{{.Var3}}  {{.Var1}}   {{.Var2}}    {{.Var2}}", []string{"Var1", "Var2", "Var3"}},
		{"{{.Var3}}XX{{.Var1}}XXX{{.Var2}}XXXX{{.Var2}}", []string{"Var1", "Var2", "Var3"}},
		{"{{.Var3}}XX{{.Var1}}XXX{{.Var2}}Var6{{.Var2}}", []string{"Var1", "Var2", "Var3"}},
		{"{{.Var3}}XX{{.Var1}}XXX{{.Var2}}.Var6{{.Var2}}", []string{"Var1", "Var2", "Var3"}},
	}

	for _, test := range tests {
		got := GetVarsFromTemplate(test.content)
		if compare := slices.Compare(got, test.expected); compare != 0 {
			t.Errorf("GetVarsFromTemplate(%q) returns %+v. Expected: %+v",
				test.content,
				got,
				test.expected,
			)
		}
	}
}

func TestCheckAllParameters(t *testing.T) {
	var noName = "noName"

	tests := []struct {
		data StringMap
		tmpl string
		err  error
	}{
		{StringMap{}, "", nil},
		{StringMap{"key1": "value1"}, "{{.key1}}", nil},
		{StringMap{"key1": "value1", "key2": "value2"}, "{{.key1}},{{.key2}}", nil},
		{StringMap{"key1": "value1", "key2": "value2"}, "{{.key1}},{{.key2}},{{.key3}}", fmt.Errorf(`template "noName": required data for field "key3" was not populated`)},
		{StringMap{"key1": "value1", "key2": "value2"}, "{{.key1}},{{.key2}},{{.key3}},{{.key4}}", fmt.Errorf(`template "noName": required data for 2 fields were not populated: "key3", "key4"`)},
	}

	for _, test := range tests {
		err := checkAllParametersProvided(noName, test.tmpl, test.data)
		// skip if no error and no error expected
		if err == test.err && test.err == nil {
			continue
		}
		// errors in both so check the error string
		if err != nil && test.err != nil && err.Error() == test.err.Error() {
			continue
		}
		if test.err != err {
			t.Errorf("checkAllParamatersProvided(%q,%q,%+v) failed.\n- returned: >>%+v<<\n- expected: >>%+v<<",
				noName,
				test.tmpl,
				test.data,
				err,
				test.err,
			)
		}
	}
}
